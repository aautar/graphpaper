{"version":3,"file":"connector-routing-worker.min.js","sources":["../src/Point.js","../src/LineIntersection.js","../src/Line.js","../src/PointSet.js","../src/LineSet.js","../src/PointVisibilityMap.js","../src/SvgPathBuilder.js","../src/ConnectorRoutingWorker.js"],"sourcesContent":["/**\r\n * \r\n * @param {Number} _x\r\n * @param {Number} _y\r\n */\r\nfunction Point(_x, _y) {\r\n\r\n    this.__x = _x;\r\n    this.__y = _y;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */     \r\nPoint.prototype.getX = function() {\r\n    return this.__x;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */     \r\nPoint.prototype.getY = function() {\r\n    return this.__y;\r\n};\r\n\r\n/**\r\n * @param {Point} _otherPoint\r\n * @returns {Boolean}\r\n */\r\nPoint.prototype.isEqual = function(_otherPoint) {\r\n    if(this.__x === _otherPoint.getX() && this.__y === _otherPoint.getY()) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * @returns {Point}\r\n */\r\nPoint.prototype.getCartesianPoint = function(_canvasWidth, _canvasHeight) {\r\n    return new Point(\r\n        this.__x - (_canvasWidth * 0.5),\r\n        -this.__y + (_canvasHeight * 0.5)\r\n    );\r\n};\r\n\r\n/**\r\n * @returns {String}\r\n */\r\nPoint.prototype.toString = function() {\r\n    return this.__x + \" \" + this.__y;\r\n};\r\n\r\nexport { Point };\r\n","import  {Point} from './Point';\r\n\r\nconst LINE_INTERSECTION_TYPE = Object.freeze({\r\n\tPARALLEL: \"parallel\",\t\t// no intersection, lines are parallel\r\n    COINCIDENT: \"coincident\",\t// no intersection, lines are coincident\r\n\tLINE: \"line\",\t\t\t\t// the lines intersect, but the intersection point is beyond the bounds of the line segments\r\n\tLINESEG: \"lineseg\",\t\t\t// the lines intersect, and the intersection point is within the bounds of the line segments\r\n});\r\n\r\n/**\r\n * \r\n * @param {LINE_INTERSECTION_TYPE} _type \r\n * @param {Point} _intersectionPoint \r\n */\r\nfunction LineIntersection(_type, _intersectionPoint) {\r\n\r\n    /**\r\n     * @returns {LINE_INTERSECTION_TYPE}\r\n     */\r\n    this.getType = function() {\r\n        return _type;\r\n    };\r\n\r\n    /**\r\n     * @returns {Point|null}\r\n     */\r\n    this.getIntersectionPoint = function() {\r\n        return _intersectionPoint;\r\n    };\r\n};\r\n\r\nexport {LINE_INTERSECTION_TYPE, LineIntersection};\r\n","import  {Point} from './Point';\r\nimport  {LINE_INTERSECTION_TYPE, LineIntersection} from './LineIntersection';\r\n\r\n/**\r\n * \r\n * @param {Point} _startPoint\r\n * @param {Point} _endPoint\r\n */\r\nfunction Line(_startPoint, _endPoint) {   \r\n\r\n    if(typeof _startPoint === 'undefined' || _startPoint === null) {\r\n        throw \"Line missing _startPoint\";\r\n    }\r\n\r\n    if(typeof _endPoint === 'undefined' || _endPoint === null) {\r\n        throw \"Line missing _endPoint\";\r\n    }\r\n\r\n    this.__startPoint = _startPoint;\r\n    this.__endPoint = _endPoint;\r\n};\r\n\r\n\r\n/**\r\n * @returns {Point}\r\n */       \r\nLine.prototype.getStartPoint = function() {\r\n    return this.__startPoint;\r\n};\r\n\r\n/**\r\n * @returns {Point}\r\n */       \r\nLine.prototype.getEndPoint = function() {\r\n    return this.__endPoint;\r\n};\r\n\r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {Boolean}\r\n */\r\nLine.prototype.isEqual = function(_otherLine) {\r\n    if(this.getStartPoint().isEqual(_otherLine.getStartPoint()) && this.getEndPoint().isEqual(_otherLine.getEndPoint())) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */\r\nLine.prototype.getLength = function() {\r\n    return Math.sqrt(\r\n        Math.pow(this.__endPoint.getX() - this.__startPoint.getX(), 2) + Math.pow(this.__endPoint.getY() - this.__startPoint.getY(), 2)\r\n    );\r\n};\r\n\r\n/**\r\n * Calculate unit length direction vector\r\n * \r\n * @returns {Point}\r\n */\r\nLine.prototype.getDirection = function() {\r\n    const dx = this.__endPoint.getX() - this.__startPoint.getX();\r\n    const dy = this.__endPoint.getY() - this.__startPoint.getY();\r\n\r\n    const len = Math.sqrt(dx*dx + dy*dy);\r\n\r\n    return new Point(       \r\n        dx / len,\r\n        dy / len\r\n    );    \r\n};\r\n\r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {LINE_INTERSECTION_TYPE}\r\n */\r\nLine.prototype.computeIntersectionType = function(_otherLine) {\r\n    const thisLineStartPointX = this.__startPoint.getX();\r\n    const thisLineStartPointY = this.__startPoint.getY();\r\n    const thisLineEndPointX = this.__endPoint.getX();\r\n    const thisLineEndPointY = this.__endPoint.getY();        \r\n    const otherLineStartPointX = _otherLine.getStartPoint().getX();\r\n    const otherLineStartPointY = _otherLine.getStartPoint().getY();\r\n    const otherLineEndPointX = _otherLine.getEndPoint().getX();\r\n    const otherLineEndPointY = _otherLine.getEndPoint().getY();\r\n\r\n    const paramDenom = (otherLineEndPointY-otherLineStartPointY)*(thisLineEndPointX-thisLineStartPointX) - (otherLineEndPointX-otherLineStartPointX)*(thisLineEndPointY-thisLineStartPointY);\r\n    const paramANumer = (otherLineEndPointX-otherLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (otherLineEndPointY - otherLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n    const paramBNumer = (thisLineEndPointX-thisLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (thisLineEndPointY-thisLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n\r\n    if(paramDenom == 0) {\r\n        if(paramDenom == 0 && paramANumer == 0 && paramBNumer==0)\r\n            return LINE_INTERSECTION_TYPE.COINCIDENT;\r\n        else\r\n            return LINE_INTERSECTION_TYPE.PARALLEL;\r\n    }\r\n\r\n    const paramA = paramANumer / paramDenom;\r\n    const paramB = paramBNumer / paramDenom;\r\n    \r\n    if(paramA > 1.0 || paramA < 0.0 || paramB > 1.0 || paramB < 0.0) {\r\n        return LINE_INTERSECTION_TYPE.LINE;\r\n    } else {\r\n        return LINE_INTERSECTION_TYPE.LINESEG;\r\n    }\r\n};\r\n    \r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {LINE_INTERSECTION_RESULT}\r\n */\r\nLine.prototype.computeIntersection = function(_otherLine) {\r\n\r\n    const thisLineStartPointX = this.__startPoint.getX();\r\n    const thisLineStartPointY = this.__startPoint.getY();\r\n    const thisLineEndPointX = this.__endPoint.getX();\r\n    const thisLineEndPointY = this.__endPoint.getY();        \r\n    const otherLineStartPointX = _otherLine.getStartPoint().getX();\r\n    const otherLineStartPointY = _otherLine.getStartPoint().getY();\r\n    const otherLineEndPointX = _otherLine.getEndPoint().getX();\r\n    const otherLineEndPointY = _otherLine.getEndPoint().getY();\r\n\r\n    const paramDenom = (otherLineEndPointY-otherLineStartPointY)*(thisLineEndPointX-thisLineStartPointX) - (otherLineEndPointX-otherLineStartPointX)*(thisLineEndPointY-thisLineStartPointY);\r\n    const paramANumer = (otherLineEndPointX-otherLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (otherLineEndPointY - otherLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n    const paramBNumer = (thisLineEndPointX-thisLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (thisLineEndPointY-thisLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n\r\n    if(paramDenom == 0) {\r\n        if(paramDenom == 0 && paramANumer == 0 && paramBNumer==0)\r\n            return new LineIntersection(LINE_INTERSECTION_TYPE.COINCIDENT, null);\r\n        else\r\n            return new LineIntersection(LINE_INTERSECTION_TYPE.PARALLEL, null);\r\n    }\r\n\r\n    const paramA = paramANumer / paramDenom;\r\n    const paramB = paramBNumer / paramDenom;\r\n\r\n    const xIntersect = this.__startPoint.getX() + paramA*(this.__endPoint.getX()-this.__startPoint.getX());\r\n    const yIntersect = this.__startPoint.getY() + paramA*(this.__endPoint.getY()-this.__startPoint.getY());\r\n    \r\n    if(paramA > 1.0 || paramA < 0.0 || paramB > 1.0 || paramB < 0.0) {\r\n        return new LineIntersection(LINE_INTERSECTION_TYPE.LINE, new Point(xIntersect, yIntersect));\r\n    } else {\r\n        return new LineIntersection(LINE_INTERSECTION_TYPE.LINESEG, new Point(xIntersect, yIntersect));\r\n    }\r\n};\r\n\r\nexport { Line };\r\n","import  {Point} from './Point';\r\nimport  {Line} from './Line';\r\n\r\n/**\r\n * Unique collection of Point objects\r\n * \r\n * @param {Point[]|Float64Array|undefined} _pointsInput\r\n */\r\nfunction PointSet(_pointsInput) {\r\n\r\n    const self = this;\r\n\r\n    /**\r\n     * @type {Point[]}\r\n     */\r\n    const points = [];\r\n\r\n    /**\r\n     * @param {Point} _newPoint\r\n     */\r\n    this.push = function(_newPoint) {\r\n        for(let i=0; i<points.length; i++) {\r\n            if(_newPoint.isEqual(points[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        points.push(_newPoint);\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {PointSet} _ps\r\n     */\r\n    this.pushPointSet = function(_ps) {\r\n        const possibleNewPoints = _ps.toArray();\r\n        for(let i=0; i<possibleNewPoints.length; i++) {\r\n            self.push(possibleNewPoints[i]);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Point} _point \r\n     * @returns {Point}\r\n     */\r\n    this.findPointClosestTo = function(_point) {\r\n        var resultPoint = null;\r\n        var currentMinLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() < currentMinLength) {\r\n                resultPoint = _pt;\r\n                currentMinLength = lineToPt.getLength();\r\n            }\r\n        });\r\n        \r\n        return resultPoint;        \r\n    };\r\n\r\n    this.findDistanceToPointClosestTo = function(_point) {\r\n        var currentMinLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() < currentMinLength) {\r\n                currentMinLength = lineToPt.getLength();\r\n            }\r\n        });\r\n        \r\n        return currentMinLength;        \r\n    };    \r\n\r\n    /**\r\n     * \r\n     * @param {Point} _point \r\n     * @returns {PointSet}\r\n     */\r\n    this.findPointsCloseTo = function(_point, _radius) {\r\n        const resultSet = new PointSet();\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() <= _radius) {\r\n                resultSet.push(_pt);\r\n            }\r\n        });\r\n        \r\n        return resultSet;        \r\n    };    \r\n\r\n    /**\r\n     * @returns {Point[]}\r\n     */\r\n    this.toArray = function() {\r\n        return points;\r\n    };\r\n\r\n    /**\r\n     * @returns {Float64Array}\r\n     */\r\n    this.toFloat64Array = function() {\r\n\r\n        const result = new Float64Array(points.length * 2);\r\n        for(let i=0; i<points.length; i++) {\r\n            result[0 + (i*2)] = points[i].getX();\r\n            result[1 + (i*2)] = points[i].getY();\r\n        }\r\n\r\n        return result;\r\n    };\r\n    \r\n    /**\r\n     * @param {Float64Array} _float64Array\r\n     */\r\n    const fromFloat64Array = function(_float64Array) {\r\n        points.length = 0;\r\n        for(let i=0; i<_float64Array.length; i+=2) {\r\n            points.push(\r\n                new Point(_float64Array[i], _float64Array[i+1])\r\n            );\r\n        }\r\n    };    \r\n\r\n    /**\r\n     * @returns {Number}\r\n     */\r\n    this.count = function() {\r\n        return points.length;\r\n    };\r\n\r\n    if(_pointsInput && Array.isArray(_pointsInput)) {\r\n        _pointsInput.forEach(self.push);\r\n    } else if(_pointsInput && Object.prototype.toString.call(_pointsInput) === '[object Float64Array]') {\r\n        fromFloat64Array(_pointsInput);\r\n    } else { }    \r\n\r\n};\r\n\r\nexport { PointSet };\r\n","import  {Point} from './Point';\r\nimport  {Line} from './Line';\r\n\r\n/**\r\n * Unique collection of Line objects\r\n * \r\n * @param {Line[]|Float64Array|undefined} _linesInput\r\n */\r\nfunction LineSet(_linesInput) {\r\n\r\n    const self = this;\r\n    \r\n    /**\r\n     * @type {Line[]}\r\n     */\r\n    const lines = [];    \r\n\r\n    /**\r\n     * @param {Line} _newLine\r\n     */\r\n    this.push = function(_newLine) {\r\n        var alreadyInLinesArray = false;\r\n        lines.forEach(function(_existingLine) {\r\n            if(_newLine.isEqual(_existingLine)) {\r\n                alreadyInLinesArray = true;\r\n            }\r\n        });        \r\n\r\n        if(alreadyInLinesArray) {\r\n            return false;\r\n        }\r\n\r\n        lines.push(_newLine);\r\n        return true;\r\n    };\r\n  \r\n    /**\r\n     * @returns {Line[]}\r\n     */\r\n    this.toArray = function() {\r\n        return lines;\r\n    };\r\n\r\n    /**\r\n     * @returns {Number}\r\n     */\r\n    this.count = function() {\r\n        return lines.length;\r\n    };\r\n\r\n    /**\r\n     * @returns {Float64Array}\r\n     */\r\n    this.toFloat64Array = function() {\r\n        const result = new Float64Array(lines.length * 4);\r\n        for(let i=0; i<lines.length; i++) {\r\n            result[0 + (i*4)] = lines[i].getStartPoint().getX();\r\n            result[1 + (i*4)] = lines[i].getStartPoint().getY();\r\n            result[2 + (i*4)] = lines[i].getEndPoint().getX();\r\n            result[3 + (i*4)] = lines[i].getEndPoint().getY();\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @param {Float64Array} _float64Array\r\n     */\r\n    const fromFloat64Array = function(_float64Array) {\r\n        lines.length = 0;\r\n        for(let i=0; i<_float64Array.length; i+=4) {\r\n            lines.push(\r\n                new Line(\r\n                    new Point(_float64Array[i], _float64Array[i+1]),\r\n                    new Point(_float64Array[i+2], _float64Array[i+3])\r\n                )\r\n            );\r\n        }\r\n    };\r\n\r\n    if(_linesInput && Array.isArray(_linesInput)) {\r\n        _linesInput.forEach(self.push);\r\n    } else if(_linesInput && Object.prototype.toString.call(_linesInput) === '[object Float64Array]') {\r\n        fromFloat64Array(_linesInput);\r\n    } else { }    \r\n};\r\n\r\nexport { LineSet };\r\n","import {Point} from './Point';\r\nimport {Line} from './Line';\r\nimport {PointSet} from './PointSet';\r\nimport {LineSet} from './LineSet';\r\nimport  {LINE_INTERSECTION_TYPE, LineIntersection} from './LineIntersection';\r\n\r\n/**\r\n * \r\n * @param {PointSet} _freePoints\r\n * @param {LineSet} _boundaryLines\r\n */\r\nfunction PointVisibilityMap(_freePoints, _boundaryLines) {\r\n\r\n    const self = this;\r\n\r\n    const boundaryLinesArr = _boundaryLines.toArray();\r\n    const freePointsArr = _freePoints.toArray();\r\n    const pointToVisibleSet = new Array(_freePoints.count()); // index represents entry in freePointsArr\r\n\r\n    /**\r\n     * @param {Line} _theLine\r\n     * @returns {Boolean}\r\n     */\r\n    const doesLineIntersectAnyBoundaryLines = function(_theLine) {\r\n\r\n        for(let b=0; b<boundaryLinesArr.length; b++) {\r\n            const intersectionType = boundaryLinesArr[b].computeIntersectionType(_theLine);\r\n            if(intersectionType === LINE_INTERSECTION_TYPE.LINESEG) {\r\n                return true;\r\n            }\r\n        };\r\n\r\n        return false;\r\n    };\r\n\r\n    const computePointsVisibility = function() {\r\n        for(let i=0; i<freePointsArr.length; i++) {\r\n            pointToVisibleSet[i] = [];   \r\n        }\r\n\r\n        for(let i=0; i<freePointsArr.length; i++) {            \r\n            for(let j=i+1; j<freePointsArr.length; j++) {\r\n\r\n                // line representing line-of-sight between the 2 points\r\n                const ijLine = new Line(freePointsArr[i], freePointsArr[j]);\r\n\r\n                if(!doesLineIntersectAnyBoundaryLines(ijLine)) {\r\n                    pointToVisibleSet[i].push(freePointsArr[j]);\r\n                    pointToVisibleSet[j].push(freePointsArr[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const getVisiblePointsFrom = function(_currentPoint) {\r\n        for(let i=0; i<freePointsArr.length; i++) {\r\n\r\n            if(freePointsArr[i].isEqual(_currentPoint)) {\r\n                const visiblePoints = pointToVisibleSet[i];\r\n                return visiblePoints;\r\n            }            \r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Number} _currentRouteLength \r\n     * @param {Point[]} _pointsInRoute \r\n     * @param {Point} _currentPoint \r\n     * @param {Point} _endPoint \r\n     * @returns {Object|null}\r\n     */\r\n    const routeToEndpoint = function(_currentRouteLength, _pointsInRoute, _currentPoint, _endPoint) {\r\n\r\n        var visiblePoints = getVisiblePointsFrom(_currentPoint);       \r\n        var curMinCost = Number.MAX_SAFE_INTEGER;\r\n        var visiblePointWithMinCost = null;\r\n\r\n        visiblePoints.forEach(function(_vp) {\r\n            // ignore point if it's already in the route\r\n            for(let i=0; i<_pointsInRoute.length; i++) {\r\n                if(_vp.isEqual(_pointsInRoute[i])) {\r\n                    return; // point already in route, try another\r\n                }\r\n            }\r\n\r\n            // g(n) = length/cost of _startPoint to _vp + _currentRouteLength\r\n            const gn = (new Line(_currentPoint, _vp)).getLength() + _currentRouteLength;\r\n\r\n            // h(n) = length/cost of _vp to _endPoint\r\n            const hn = (new Line(_vp, _endPoint)).getLength();\r\n\r\n            // see if this is the new min\r\n            if((gn + hn) < curMinCost) {\r\n                curMinCost = gn + hn;\r\n                visiblePointWithMinCost = _vp;\r\n            }\r\n        });\r\n\r\n        if(curMinCost === Number.MAX_SAFE_INTEGER) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            \"cost\": curMinCost,\r\n            \"point\": visiblePointWithMinCost\r\n        };\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Array} _pointsInRoute \r\n     */\r\n    const optimizeRoute = function(_pointsInRoute) {\r\n\r\n        let ptrA = 0;\r\n\r\n        while(true) {\r\n\r\n            if(ptrA+2 >= _pointsInRoute.length) {\r\n                break;\r\n            }            \r\n\r\n            const ln = new Line(_pointsInRoute[ptrA], _pointsInRoute[ptrA + 2]);\r\n\r\n            if(!doesLineIntersectAnyBoundaryLines(ln)) {\r\n                _pointsInRoute.splice(ptrA + 1, 1);\r\n            } else {\r\n                ptrA++;\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _point\r\n     * @returns {Point|null}\r\n     */\r\n    this.findPointClosestTo = function(_point) {\r\n        var resultPoint = null;\r\n        var currentMaxLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        freePointsArr.forEach(function(_ptKey) {\r\n            const lineOfSight = new Line(_point, _ptKey);\r\n            if(lineOfSight.getLength() < currentMaxLength) {\r\n                resultPoint = _ptKey;\r\n                currentMaxLength = lineOfSight.getLength();\r\n            }\r\n        });\r\n        \r\n        return resultPoint;\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _point\r\n     * @returns {Point|null}\r\n     */\r\n    this.findVisiblePointClosestTo = function(_point) {\r\n\r\n        var resultPoint = null;\r\n        var currentMaxLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        freePointsArr.forEach(function(_freePt) {\r\n\r\n            const lineOfSight = new Line(_point, _freePt);\r\n            const lineOfSightLength = lineOfSight.getLength();\r\n\r\n            if(lineOfSightLength < currentMaxLength && !doesLineIntersectAnyBoundaryLines(lineOfSight)) {\r\n                resultPoint = _freePt;\r\n                currentMaxLength = lineOfSightLength;\r\n            };\r\n\r\n        });\r\n        \r\n        return resultPoint;\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _startPoint\r\n     * @param {Point} _endPoint\r\n     * \r\n     * @return {PointSet}\r\n     */\r\n    this.computeRoute = function(_startPoint, _endPoint) {\r\n\r\n        // if no valid startpoint or endpoint, we can't route\r\n        if(_startPoint === null || _endPoint === null) {\r\n            return new PointSet();\r\n        }\r\n\r\n        // find closest visible point \r\n        const firstRoutingPoint = self.findVisiblePointClosestTo(_startPoint);\r\n        if(firstRoutingPoint === null) {\r\n            return new PointSet();\r\n        }\r\n\r\n        var currentRouteLen = 0;\r\n        const pointsInRoute = [firstRoutingPoint];\r\n        var currentPoint = firstRoutingPoint;\r\n        while(true) {\r\n            const routeSegment = routeToEndpoint(currentRouteLen, pointsInRoute, currentPoint, _endPoint);\r\n            if(routeSegment === null) {\r\n\r\n                // Is there unobstructed line to endpoint? \r\n                // If not, failed to find route\r\n                const lastSegmentToEndpoint = new Line(pointsInRoute[pointsInRoute.length-1], _endPoint);\r\n                if(doesLineIntersectAnyBoundaryLines(lastSegmentToEndpoint)) {\r\n                    return new PointSet();\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            currentRouteLen += (new Line(currentPoint, routeSegment.point)).getLength();\r\n            pointsInRoute.push(routeSegment.point);\r\n            currentPoint = routeSegment.point;\r\n\r\n            if((new Line(currentPoint, _endPoint).getLength()) < 1.0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        optimizeRoute(pointsInRoute);\r\n\r\n        return new PointSet(pointsInRoute);\r\n\r\n    };\r\n\r\n    computePointsVisibility();\r\n};\r\n    \r\nexport { PointVisibilityMap };\r\n","const SvgPathBuilder = {\r\n\r\n    /**\r\n     * \r\n     * @param {Point} _pt \r\n     * @returns {String}\r\n     */\r\n    pointToLineTo: function(_pt) {\r\n        return \"L\" + _pt.getX() + \" \" + _pt.getY();\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {Point[]} _points \r\n     * @returns {String}\r\n     */\r\n    pointsToPath: function(_points) {\r\n        const startPt = _points[0];\r\n\r\n        const lineToString = [];\r\n        for(let i=1; i<_points.length; i++) {\r\n            const p = _points[i];\r\n            lineToString.push(SvgPathBuilder.pointToLineTo(p));\r\n        }\r\n        \r\n        const startCoordString = startPt.getX() + \" \" + startPt.getY();\r\n        const pathString = 'M' + startCoordString + lineToString.join(\" \");\r\n\r\n        return pathString;\r\n    },\r\n\r\n};\r\n\r\nexport { SvgPathBuilder };\r\n","import {Point} from './Point';\r\nimport {PointSet} from './PointSet';\r\nimport {LineSet} from './LineSet';\r\nimport {PointVisibilityMap} from './PointVisibilityMap';\r\nimport {SvgPathBuilder} from './SvgPathBuilder';\r\n\r\n/**\r\n * \r\n * @param {Object} _connectorDescriptor\r\n * @param {PointSet} _routingPointsAroundAnchorSet\r\n * @param {PointVisibilityMap} _pointVisibilityMap \r\n * \r\n * @returns {Object}\r\n */\r\nconst computeConnectorPath = function(_connectorDescriptor, _routingPointsAroundAnchorSet, _pointVisibilityMap) {\r\n\r\n    const anchorStartStringParts = _connectorDescriptor.anchor_start_centroid.split(' ');\r\n    const anchorEndStringParts = _connectorDescriptor.anchor_end_centroid.split(' ');\r\n\r\n    const anchorStartCentroid = new Point(parseFloat(anchorStartStringParts[0]), parseFloat(anchorStartStringParts[1]));\r\n    const anchorEndCentroid = new Point(parseFloat(anchorEndStringParts[0]), parseFloat(anchorEndStringParts[1]));\r\n    const anchorPointMinDist = _routingPointsAroundAnchorSet.findDistanceToPointClosestTo(anchorStartCentroid);\r\n\r\n    // Find adjustedStart, adjustedEnd .. anchor points closest to the desired start point and end point\r\n    // Note that when desired start or end are closed off within a boundary, values will be null\r\n    const adjustedStart = _routingPointsAroundAnchorSet\r\n        .findPointsCloseTo(anchorStartCentroid, anchorPointMinDist) // get all points within radius\r\n        .findPointClosestTo(anchorEndCentroid); // for all points within radius, get the once closest to the endpoint\r\n\r\n    const adjustedEnd = _routingPointsAroundAnchorSet\r\n        .findPointsCloseTo(anchorEndCentroid, anchorPointMinDist)\r\n        .findPointClosestTo(anchorStartCentroid);\r\n\r\n    const routingPoints = _pointVisibilityMap.computeRoute(adjustedStart, adjustedEnd);\r\n    const routingPointsArray = routingPoints.toArray();\r\n\r\n    // Put together all points for path\r\n    const allPointsForPath = [anchorStartCentroid, ...routingPointsArray, anchorEndCentroid];\r\n\r\n    return {\r\n        \"svgPath\": SvgPathBuilder.pointsToPath(allPointsForPath),\r\n        \"pointsInPath\": allPointsForPath,\r\n    }\r\n};\r\n\r\nconst convertArrayBufferToFloat64Array = function(_ab) {\r\n    return new Float64Array(_ab);\r\n};\r\n\r\nonmessage = function(_msg) {\r\n\r\n    const metrics = {};\r\n    metrics.overallTime = null;\r\n    const overallTimeT1 = new Date();\r\n\r\n    const gridSize = _msg.data.gridSize;\r\n\r\n    const connectorDescriptors = _msg.data.connectorDescriptors;\r\n\r\n    const routingPointsSet = new PointSet(convertArrayBufferToFloat64Array(_msg.data.routingPoints));\r\n    const boundaryLinesSet = new LineSet(convertArrayBufferToFloat64Array(_msg.data.boundaryLines));    \r\n    const routingPointsAroundAnchorSet = new PointSet(convertArrayBufferToFloat64Array(_msg.data.routingPointsAroundAnchor));    \r\n    \r\n    const currentPointVisiblityMap = new PointVisibilityMap(\r\n        routingPointsSet,\r\n        boundaryLinesSet\r\n    );\r\n\r\n    connectorDescriptors.forEach(function(_cd) {\r\n        const pathData = computeConnectorPath(_cd, routingPointsAroundAnchorSet, currentPointVisiblityMap);\r\n\r\n        const pointsInPathPointSet = new PointSet(pathData.pointsInPath);\r\n\r\n        _cd.svgPath = pathData.svgPath;\r\n        _cd.pointsInPath = pointsInPathPointSet.toFloat64Array().buffer;\r\n    });\r\n\r\n    metrics.overallTime = (new Date()) - overallTimeT1;\r\n    metrics.numRoutingPoints = routingPointsSet.count();\r\n    metrics.numBoundaryLines = boundaryLinesSet.count();\r\n\r\n    postMessage(\r\n        {\r\n            \"connectorDescriptors\": connectorDescriptors,\r\n            \"metrics\": metrics\r\n        }\r\n    );\r\n\r\n};\r\n"],"names":["Point","_x","_y","__x","__y","prototype","getX","getY","isEqual","_otherPoint","getCartesianPoint","_canvasWidth","_canvasHeight","toString","LINE_INTERSECTION_TYPE","Object","freeze","PARALLEL","COINCIDENT","LINE","LINESEG","LineIntersection","_type","_intersectionPoint","getType","getIntersectionPoint","Line","_startPoint","_endPoint","__startPoint","__endPoint","getStartPoint","getEndPoint","_otherLine","getLength","Math","sqrt","pow","getDirection","dx","dy","len","computeIntersectionType","thisLineStartPointX","thisLineStartPointY","thisLineEndPointX","thisLineEndPointY","otherLineStartPointX","otherLineStartPointY","otherLineEndPointX","otherLineEndPointY","paramDenom","paramANumer","paramBNumer","paramA","paramB","computeIntersection","xIntersect","yIntersect","PointSet","_pointsInput","self","points","push","_newPoint","i","length","pushPointSet","_ps","possibleNewPoints","toArray","findPointClosestTo","_point","resultPoint","currentMinLength","Number","MAX_SAFE_INTEGER","forEach","_pt","lineToPt","findDistanceToPointClosestTo","findPointsCloseTo","_radius","resultSet","toFloat64Array","result","Float64Array","fromFloat64Array","_float64Array","count","Array","isArray","call","LineSet","_linesInput","lines","_newLine","alreadyInLinesArray","_existingLine","PointVisibilityMap","_freePoints","_boundaryLines","boundaryLinesArr","freePointsArr","pointToVisibleSet","doesLineIntersectAnyBoundaryLines","_theLine","intersectionType","b","computePointsVisibility","ijLine","j","getVisiblePointsFrom","_currentPoint","visiblePoints","routeToEndpoint","_currentRouteLength","_pointsInRoute","curMinCost","visiblePointWithMinCost","_vp","gn","hn","optimizeRoute","ptrA","ln","splice","currentMaxLength","_ptKey","lineOfSight","findVisiblePointClosestTo","_freePt","lineOfSightLength","computeRoute","firstRoutingPoint","routeSegment","currentRouteLen","pointsInRoute","currentPoint","lastSegmentToEndpoint","point","SvgPathBuilder","pointToLineTo","pointsToPath","_points","p","startPt","lineToString","startCoordString","pathString","join","computeConnectorPath","_connectorDescriptor","_routingPointsAroundAnchorSet","_pointVisibilityMap","anchorStartStringParts","anchor_start_centroid","split","anchorEndStringParts","anchor_end_centroid","anchorStartCentroid","parseFloat","anchorEndCentroid","anchorPointMinDist","adjustedStart","adjustedEnd","routingPoints","routingPointsArray","allPointsForPath","convertArrayBufferToFloat64Array","_ab","onmessage","_msg","metrics","overallTime","overallTimeT1","Date","gridSize","data","connectorDescriptors","routingPointsSet","boundaryLinesSet","boundaryLines","routingPointsAroundAnchorSet","routingPointsAroundAnchor","currentPointVisiblityMap","_cd","pathData","pointsInPathPointSet","pointsInPath","svgPath","buffer","numRoutingPoints","numBoundaryLines","postMessage"],"mappings":"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"}