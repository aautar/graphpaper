{"version":3,"file":"connector-routing-worker.min.js","sources":["../src/Point.js","../src/LineIntersection.js","../src/Line.js","../src/PointSet.js","../src/LineSet.js","../src/PointVisibilityMap.js","../src/SvgPathBuilder.js","../src/ConnectorRoutingWorker.js"],"sourcesContent":["/**\r\n * \r\n * @param {Number} _x\r\n * @param {Number} _y\r\n */\r\nfunction Point(_x, _y) {\r\n\r\n    this.__x = _x;\r\n    this.__y = _y;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */     \r\nPoint.prototype.getX = function() {\r\n    return this.__x;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */     \r\nPoint.prototype.getY = function() {\r\n    return this.__y;\r\n};\r\n\r\n/**\r\n * @param {Point} _otherPoint\r\n * @returns {Boolean}\r\n */\r\nPoint.prototype.isEqual = function(_otherPoint) {\r\n    if(this.__x === _otherPoint.getX() && this.__y === _otherPoint.getY()) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * @returns {Point}\r\n */\r\nPoint.prototype.getCartesianPoint = function(_canvasWidth, _canvasHeight) {\r\n    return new Point(\r\n        this.__x - (_canvasWidth * 0.5),\r\n        -this.__y + (_canvasHeight * 0.5)\r\n    );\r\n};\r\n\r\n/**\r\n * @returns {String}\r\n */\r\nPoint.prototype.toString = function() {\r\n    return this.__x + \" \" + this.__y;\r\n};\r\n\r\nexport { Point };\r\n","import  {Point} from './Point';\r\n\r\nconst LINE_INTERSECTION_TYPE = Object.freeze({\r\n\tPARALLEL: \"parallel\",\t\t// no intersection, lines are parallel\r\n    COINCIDENT: \"coincident\",\t// no intersection, lines are coincident\r\n\tLINE: \"line\",\t\t\t\t// the lines intersect, but the intersection point is beyond the bounds of the line segments\r\n\tLINESEG: \"lineseg\",\t\t\t// the lines intersect, and the intersection point is within the bounds of the line segments\r\n});\r\n\r\n/**\r\n * \r\n * @param {LINE_INTERSECTION_TYPE} _type \r\n * @param {Point} _intersectionPoint \r\n */\r\nfunction LineIntersection(_type, _intersectionPoint) {\r\n\r\n    /**\r\n     * @returns {LINE_INTERSECTION_TYPE}\r\n     */\r\n    this.getType = function() {\r\n        return _type;\r\n    };\r\n\r\n    /**\r\n     * @returns {Point|null}\r\n     */\r\n    this.getIntersectionPoint = function() {\r\n        return _intersectionPoint;\r\n    };\r\n};\r\n\r\nexport {LINE_INTERSECTION_TYPE, LineIntersection};\r\n","import  {Point} from './Point';\r\nimport  {LINE_INTERSECTION_TYPE, LineIntersection} from './LineIntersection';\r\n\r\n/**\r\n * \r\n * @param {Point} _startPoint\r\n * @param {Point} _endPoint\r\n */\r\nfunction Line(_startPoint, _endPoint) {   \r\n\r\n    if(typeof _startPoint === 'undefined' || _startPoint === null) {\r\n        throw \"Line missing _startPoint\";\r\n    }\r\n\r\n    if(typeof _endPoint === 'undefined' || _endPoint === null) {\r\n        throw \"Line missing _endPoint\";\r\n    }\r\n\r\n    this.__startPoint = _startPoint;\r\n    this.__endPoint = _endPoint;\r\n};\r\n\r\n\r\n/**\r\n * @returns {Point}\r\n */       \r\nLine.prototype.getStartPoint = function() {\r\n    return this.__startPoint;\r\n};\r\n\r\n/**\r\n * @returns {Point}\r\n */       \r\nLine.prototype.getEndPoint = function() {\r\n    return this.__endPoint;\r\n};\r\n\r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {Boolean}\r\n */\r\nLine.prototype.isEqual = function(_otherLine) {\r\n    if(this.getStartPoint().isEqual(_otherLine.getStartPoint()) && this.getEndPoint().isEqual(_otherLine.getEndPoint())) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * @returns {Number}\r\n */\r\nLine.prototype.getLength = function() {\r\n    return Math.sqrt(\r\n        Math.pow(this.__endPoint.getX() - this.__startPoint.getX(), 2) + Math.pow(this.__endPoint.getY() - this.__startPoint.getY(), 2)\r\n    );\r\n};\r\n\r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {LINE_INTERSECTION_TYPE}\r\n */\r\nLine.prototype.computeIntersectionType = function(_otherLine) {\r\n    const thisLineStartPointX = this.__startPoint.getX();\r\n    const thisLineStartPointY = this.__startPoint.getY();\r\n    const thisLineEndPointX = this.__endPoint.getX();\r\n    const thisLineEndPointY = this.__endPoint.getY();        \r\n    const otherLineStartPointX = _otherLine.getStartPoint().getX();\r\n    const otherLineStartPointY = _otherLine.getStartPoint().getY();\r\n    const otherLineEndPointX = _otherLine.getEndPoint().getX();\r\n    const otherLineEndPointY = _otherLine.getEndPoint().getY();\r\n\r\n    const paramDenom = (otherLineEndPointY-otherLineStartPointY)*(thisLineEndPointX-thisLineStartPointX) - (otherLineEndPointX-otherLineStartPointX)*(thisLineEndPointY-thisLineStartPointY);\r\n    const paramANumer = (otherLineEndPointX-otherLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (otherLineEndPointY - otherLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n    const paramBNumer = (thisLineEndPointX-thisLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (thisLineEndPointY-thisLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n\r\n    if(paramDenom == 0) {\r\n        if(paramDenom == 0 && paramANumer == 0 && paramBNumer==0)\r\n            return LINE_INTERSECTION_TYPE.COINCIDENT;\r\n        else\r\n            return LINE_INTERSECTION_TYPE.PARALLEL;\r\n    }\r\n\r\n    const paramA = paramANumer / paramDenom;\r\n    const paramB = paramBNumer / paramDenom;\r\n    \r\n    if(paramA > 1.0 || paramA < 0.0 || paramB > 1.0 || paramB < 0.0) {\r\n        return LINE_INTERSECTION_TYPE.LINE;\r\n    } else {\r\n        return LINE_INTERSECTION_TYPE.LINESEG;\r\n    }\r\n};\r\n    \r\n/**\r\n * @param {Line} _otherLine\r\n * @returns {LINE_INTERSECTION_RESULT}\r\n */\r\nLine.prototype.computeIntersection = function(_otherLine) {\r\n\r\n    const thisLineStartPointX = this.__startPoint.getX();\r\n    const thisLineStartPointY = this.__startPoint.getY();\r\n    const thisLineEndPointX = this.__endPoint.getX();\r\n    const thisLineEndPointY = this.__endPoint.getY();        \r\n    const otherLineStartPointX = _otherLine.getStartPoint().getX();\r\n    const otherLineStartPointY = _otherLine.getStartPoint().getY();\r\n    const otherLineEndPointX = _otherLine.getEndPoint().getX();\r\n    const otherLineEndPointY = _otherLine.getEndPoint().getY();\r\n\r\n    const paramDenom = (otherLineEndPointY-otherLineStartPointY)*(thisLineEndPointX-thisLineStartPointX) - (otherLineEndPointX-otherLineStartPointX)*(thisLineEndPointY-thisLineStartPointY);\r\n    const paramANumer = (otherLineEndPointX-otherLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (otherLineEndPointY - otherLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n    const paramBNumer = (thisLineEndPointX-thisLineStartPointX)*(thisLineStartPointY-otherLineStartPointY) - (thisLineEndPointY-thisLineStartPointY)*(thisLineStartPointX-otherLineStartPointX);\r\n\r\n    if(paramDenom == 0) {\r\n        if(paramDenom == 0 && paramANumer == 0 && paramBNumer==0)\r\n            return new LineIntersection(LINE_INTERSECTION_TYPE.COINCIDENT, null);\r\n        else\r\n            return new LineIntersection(LINE_INTERSECTION_TYPE.PARALLEL, null);\r\n    }\r\n\r\n    const paramA = paramANumer / paramDenom;\r\n    const paramB = paramBNumer / paramDenom;\r\n\r\n    const xIntersect = this.__startPoint.getX() + paramA*(this.__endPoint.getX()-this.__startPoint.getX());\r\n    const yIntersect = this.__startPoint.getY() + paramA*(this.__endPoint.getY()-this.__startPoint.getY());\r\n    \r\n    if(paramA > 1.0 || paramA < 0.0 || paramB > 1.0 || paramB < 0.0) {\r\n        return new LineIntersection(LINE_INTERSECTION_TYPE.LINE, new Point(xIntersect, yIntersect));\r\n    } else {\r\n        return new LineIntersection(LINE_INTERSECTION_TYPE.LINESEG, new Point(xIntersect, yIntersect));\r\n    }\r\n};\r\n\r\nexport { Line };\r\n","import  {Point} from './Point';\r\nimport  {Line} from './Line';\r\n\r\n/**\r\n * Unique collection of Point objects\r\n * \r\n * @param {Point[]|Float64Array|undefined} _pointsInput\r\n */\r\nfunction PointSet(_pointsInput) {\r\n\r\n    const self = this;\r\n\r\n    /**\r\n     * @type {Point[]}\r\n     */\r\n    const points = [];\r\n\r\n    /**\r\n     * @param {Point} _newPoint\r\n     */\r\n    this.push = function(_newPoint) {\r\n        for(let i=0; i<points.length; i++) {\r\n            if(_newPoint.isEqual(points[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        points.push(_newPoint);\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {PointSet} _ps\r\n     */\r\n    this.pushPointSet = function(_ps) {\r\n        const possibleNewPoints = _ps.toArray();\r\n        for(let i=0; i<possibleNewPoints.length; i++) {\r\n            self.push(possibleNewPoints[i]);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Point} _point \r\n     * @returns {Point}\r\n     */\r\n    this.findPointClosestTo = function(_point) {\r\n        var resultPoint = null;\r\n        var currentMinLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() < currentMinLength) {\r\n                resultPoint = _pt;\r\n                currentMinLength = lineToPt.getLength();\r\n            }\r\n        });\r\n        \r\n        return resultPoint;        \r\n    };\r\n\r\n    this.findDistanceToPointClosestTo = function(_point) {\r\n        var currentMinLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() < currentMinLength) {\r\n                currentMinLength = lineToPt.getLength();\r\n            }\r\n        });\r\n        \r\n        return currentMinLength;        \r\n    };    \r\n\r\n    /**\r\n     * \r\n     * @param {Point} _point \r\n     * @returns {PointSet}\r\n     */\r\n    this.findPointsCloseTo = function(_point, _radius) {\r\n        const resultSet = new PointSet();\r\n\r\n        points.forEach(function(_pt) {\r\n            const lineToPt = new Line(_point, _pt);\r\n            if(lineToPt.getLength() <= _radius) {\r\n                resultSet.push(_pt);\r\n            }\r\n        });\r\n        \r\n        return resultSet;        \r\n    };    \r\n\r\n    /**\r\n     * @returns {Point[]}\r\n     */\r\n    this.toArray = function() {\r\n        return points;\r\n    };\r\n\r\n    /**\r\n     * @returns {Float64Array}\r\n     */\r\n    this.toFloat64Array = function() {\r\n\r\n        const result = new Float64Array(points.length * 2);\r\n        for(let i=0; i<points.length; i++) {\r\n            result[0 + (i*2)] = points[i].getX();\r\n            result[1 + (i*2)] = points[i].getY();\r\n        }\r\n\r\n        return result;\r\n    };\r\n    \r\n    /**\r\n     * @param {Float64Array} _float64Array\r\n     */\r\n    const fromFloat64Array = function(_float64Array) {\r\n        points.length = 0;\r\n        for(let i=0; i<_float64Array.length; i+=2) {\r\n            points.push(\r\n                new Point(_float64Array[i], _float64Array[i+1])\r\n            );\r\n        }\r\n    };    \r\n\r\n    /**\r\n     * @returns {Number}\r\n     */\r\n    this.count = function() {\r\n        return points.length;\r\n    };\r\n\r\n    if(_pointsInput && Array.isArray(_pointsInput)) {\r\n        _pointsInput.forEach(self.push);\r\n    } else if(_pointsInput && Object.prototype.toString.call(_pointsInput) === '[object Float64Array]') {\r\n        fromFloat64Array(_pointsInput);\r\n    } else { }    \r\n\r\n};\r\n\r\nexport { PointSet };\r\n","import  {Point} from './Point';\r\nimport  {Line} from './Line';\r\n\r\n/**\r\n * Unique collection of Line objects\r\n * \r\n * @param {Line[]|Float64Array|undefined} _linesInput\r\n */\r\nfunction LineSet(_linesInput) {\r\n\r\n    const self = this;\r\n    \r\n    /**\r\n     * @type {Line[]}\r\n     */\r\n    const lines = [];    \r\n\r\n    /**\r\n     * @param {Line} _newLine\r\n     */\r\n    this.push = function(_newLine) {\r\n        var alreadyInLinesArray = false;\r\n        lines.forEach(function(_existingLine) {\r\n            if(_newLine.isEqual(_existingLine)) {\r\n                alreadyInLinesArray = true;\r\n            }\r\n        });        \r\n\r\n        if(alreadyInLinesArray) {\r\n            return false;\r\n        }\r\n\r\n        lines.push(_newLine);\r\n        return true;\r\n    };\r\n  \r\n    /**\r\n     * @returns {Line[]}\r\n     */\r\n    this.toArray = function() {\r\n        return lines;\r\n    };\r\n\r\n    /**\r\n     * @returns {Number}\r\n     */\r\n    this.count = function() {\r\n        return lines.length;\r\n    };\r\n\r\n    /**\r\n     * @returns {Float64Array}\r\n     */\r\n    this.toFloat64Array = function() {\r\n        const result = new Float64Array(lines.length * 4);\r\n        for(let i=0; i<lines.length; i++) {\r\n            result[0 + (i*4)] = lines[i].getStartPoint().getX();\r\n            result[1 + (i*4)] = lines[i].getStartPoint().getY();\r\n            result[2 + (i*4)] = lines[i].getEndPoint().getX();\r\n            result[3 + (i*4)] = lines[i].getEndPoint().getY();\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @param {Float64Array} _float64Array\r\n     */\r\n    const fromFloat64Array = function(_float64Array) {\r\n        lines.length = 0;\r\n        for(let i=0; i<_float64Array.length; i+=4) {\r\n            lines.push(\r\n                new Line(\r\n                    new Point(_float64Array[i], _float64Array[i+1]),\r\n                    new Point(_float64Array[i+2], _float64Array[i+3])\r\n                )\r\n            );\r\n        }\r\n    };\r\n\r\n    if(_linesInput && Array.isArray(_linesInput)) {\r\n        _linesInput.forEach(self.push);\r\n    } else if(_linesInput && Object.prototype.toString.call(_linesInput) === '[object Float64Array]') {\r\n        fromFloat64Array(_linesInput);\r\n    } else { }    \r\n};\r\n\r\nexport { LineSet };\r\n","import {Point} from './Point';\r\nimport {Line} from './Line';\r\nimport {PointSet} from './PointSet';\r\nimport {LineSet} from './LineSet';\r\nimport  {LINE_INTERSECTION_TYPE, LineIntersection} from './LineIntersection';\r\n\r\n/**\r\n * \r\n * @param {PointSet} _freePoints\r\n * @param {LineSet} _boundaryLines\r\n */\r\nfunction PointVisibilityMap(_freePoints, _boundaryLines) {\r\n\r\n    const self = this;\r\n\r\n    const boundaryLinesArr = _boundaryLines.toArray();\r\n    const freePointsArr = _freePoints.toArray();\r\n    const pointToVisibleSet = new Array(_freePoints.count()); // index represents entry in freePointsArr\r\n\r\n    /**\r\n     * @param {Line} _theLine\r\n     * @returns {Boolean}\r\n     */\r\n    const doesLineIntersectAnyBoundaryLines = function(_theLine) {\r\n\r\n        for(let b=0; b<boundaryLinesArr.length; b++) {\r\n            const intersectionType = boundaryLinesArr[b].computeIntersectionType(_theLine);\r\n            if(intersectionType === LINE_INTERSECTION_TYPE.LINESEG) {\r\n                return true;\r\n            }\r\n        };\r\n\r\n        return false;\r\n    };\r\n\r\n    const computePointsVisibility = function() {\r\n        for(let i=0; i<freePointsArr.length; i++) {\r\n            pointToVisibleSet[i] = [];   \r\n        }\r\n\r\n        for(let i=0; i<freePointsArr.length; i++) {            \r\n            for(let j=i+1; j<freePointsArr.length; j++) {\r\n\r\n                // line representing line-of-sight between the 2 points\r\n                const ijLine = new Line(freePointsArr[i], freePointsArr[j]);\r\n\r\n                if(!doesLineIntersectAnyBoundaryLines(ijLine)) {\r\n                    pointToVisibleSet[i].push(freePointsArr[j]);\r\n                    pointToVisibleSet[j].push(freePointsArr[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const getVisiblePointsFrom = function(_currentPoint) {\r\n        for(let i=0; i<freePointsArr.length; i++) {\r\n\r\n            if(freePointsArr[i].isEqual(_currentPoint)) {\r\n                const visiblePoints = pointToVisibleSet[i];\r\n                return visiblePoints;\r\n            }            \r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Number} _currentRouteLength \r\n     * @param {Point[]} _pointsInRoute \r\n     * @param {Point} _currentPoint \r\n     * @param {Point} _endPoint \r\n     * @returns {Object|null}\r\n     */\r\n    const routeToEndpoint = function(_currentRouteLength, _pointsInRoute, _currentPoint, _endPoint) {\r\n\r\n        var visiblePoints = getVisiblePointsFrom(_currentPoint);       \r\n        var curMinCost = Number.MAX_SAFE_INTEGER;\r\n        var visiblePointWithMinCost = null;\r\n\r\n        visiblePoints.forEach(function(_vp) {\r\n            // ignore point if it's already in the route\r\n            for(let i=0; i<_pointsInRoute.length; i++) {\r\n                if(_vp.isEqual(_pointsInRoute[i])) {\r\n                    return; // point already in route, try another\r\n                }\r\n            }\r\n\r\n            // g(n) = length/cost of _startPoint to _vp + _currentRouteLength\r\n            const gn = (new Line(_currentPoint, _vp)).getLength() + _currentRouteLength;\r\n\r\n            // h(n) = length/cost of _vp to _endPoint\r\n            const hn = (new Line(_vp, _endPoint)).getLength();\r\n\r\n            // see if this is the new min\r\n            if((gn + hn) < curMinCost) {\r\n                curMinCost = gn + hn;\r\n                visiblePointWithMinCost = _vp;\r\n            }\r\n        });\r\n\r\n        if(curMinCost === Number.MAX_SAFE_INTEGER) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            \"cost\": curMinCost,\r\n            \"point\": visiblePointWithMinCost\r\n        };\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {Array} _pointsInRoute \r\n     */\r\n    const optimizeRoute = function(_pointsInRoute) {\r\n\r\n        let ptrA = 0;\r\n\r\n        while(true) {\r\n\r\n            if(ptrA+2 >= _pointsInRoute.length) {\r\n                break;\r\n            }            \r\n\r\n            const ln = new Line(_pointsInRoute[ptrA], _pointsInRoute[ptrA + 2]);\r\n\r\n            if(!doesLineIntersectAnyBoundaryLines(ln)) {\r\n                _pointsInRoute.splice(ptrA + 1, 1);\r\n            } else {\r\n                ptrA++;\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _point\r\n     * @returns {Point|null}\r\n     */\r\n    this.findPointClosestTo = function(_point) {\r\n        var resultPoint = null;\r\n        var currentMaxLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        freePointsArr.forEach(function(_ptKey) {\r\n            const lineOfSight = new Line(_point, _ptKey);\r\n            if(lineOfSight.getLength() < currentMaxLength) {\r\n                resultPoint = _ptKey;\r\n                currentMaxLength = lineOfSight.getLength();\r\n            }\r\n        });\r\n        \r\n        return resultPoint;\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _point\r\n     * @returns {Point|null}\r\n     */\r\n    this.findVisiblePointClosestTo = function(_point) {\r\n\r\n        var resultPoint = null;\r\n        var currentMaxLength = Number.MAX_SAFE_INTEGER;\r\n\r\n        freePointsArr.forEach(function(_freePt) {\r\n\r\n            const lineOfSight = new Line(_point, _freePt);\r\n            const lineOfSightLength = lineOfSight.getLength();\r\n\r\n            if(lineOfSightLength < currentMaxLength && !doesLineIntersectAnyBoundaryLines(lineOfSight)) {\r\n                resultPoint = _freePt;\r\n                currentMaxLength = lineOfSightLength;\r\n            };\r\n\r\n        });\r\n        \r\n        return resultPoint;\r\n    };\r\n\r\n    /**\r\n     * @param {Point} _startPoint\r\n     * @param {Point} _endPoint\r\n     * \r\n     * @return {PointSet}\r\n     */\r\n    this.computeRoute = function(_startPoint, _endPoint) {\r\n\r\n        // if no valid startpoint or endpoint, we can't route\r\n        if(_startPoint === null || _endPoint === null) {\r\n            return new PointSet();\r\n        }\r\n\r\n        // find closest visible point \r\n        const firstRoutingPoint = self.findVisiblePointClosestTo(_startPoint);\r\n        if(firstRoutingPoint === null) {\r\n            return new PointSet();\r\n        }\r\n\r\n        var currentRouteLen = 0;\r\n        const pointsInRoute = [firstRoutingPoint];\r\n        var currentPoint = firstRoutingPoint;\r\n        while(true) {\r\n            const routeSegment = routeToEndpoint(currentRouteLen, pointsInRoute, currentPoint, _endPoint);\r\n            if(routeSegment === null) {\r\n\r\n                // Is there unobstructed line to endpoint? \r\n                // If not, failed to find route\r\n                const lastSegmentToEndpoint = new Line(pointsInRoute[pointsInRoute.length-1], _endPoint);\r\n                if(doesLineIntersectAnyBoundaryLines(lastSegmentToEndpoint)) {\r\n                    return new PointSet();\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            currentRouteLen += (new Line(currentPoint, routeSegment.point)).getLength();\r\n            pointsInRoute.push(routeSegment.point);\r\n            currentPoint = routeSegment.point;\r\n\r\n            if((new Line(currentPoint, _endPoint).getLength()) < 1.0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        optimizeRoute(pointsInRoute);\r\n\r\n        return new PointSet(pointsInRoute);\r\n\r\n    };\r\n\r\n    computePointsVisibility();\r\n};\r\n    \r\nexport { PointVisibilityMap };\r\n","const SvgPathBuilder = {\r\n\r\n    /**\r\n     * \r\n     * @param {Point} _pt \r\n     * @returns {String}\r\n     */\r\n    pointToLineTo: function(_pt) {\r\n        return \"L\" + _pt.getX() + \" \" + _pt.getY();\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {Point[]} _points \r\n     * @returns {String}\r\n     */\r\n    pointsToPath: function(_points) {\r\n        const startPt = _points[0];\r\n\r\n        const lineToString = [];\r\n        for(let i=1; i<_points.length; i++) {\r\n            const p = _points[i];\r\n            lineToString.push(SvgPathBuilder.pointToLineTo(p));\r\n        }\r\n        \r\n        const startCoordString = startPt.getX() + \" \" + startPt.getY();\r\n        const pathString = 'M' + startCoordString + lineToString.join(\" \");\r\n\r\n        return pathString;\r\n    },\r\n\r\n};\r\n\r\nexport { SvgPathBuilder };\r\n","import {Point} from './Point';\r\nimport {PointSet} from './PointSet';\r\nimport {LineSet} from './LineSet';\r\nimport {PointVisibilityMap} from './PointVisibilityMap';\r\nimport {SvgPathBuilder} from './SvgPathBuilder';\r\n\r\n/**\r\n * \r\n * @param {Object} _connectorDescriptor\r\n * @param {PointSet} _routingPointsAroundAnchorSet\r\n * @param {PointVisibilityMap} _pointVisibilityMap \r\n * \r\n * @returns {Object}\r\n */\r\nconst computeConnectorPath = function(_connectorDescriptor, _routingPointsAroundAnchorSet, _pointVisibilityMap) {\r\n\r\n    const anchorStartStringParts = _connectorDescriptor.anchor_start_centroid.split(' ');\r\n    const anchorEndStringParts = _connectorDescriptor.anchor_end_centroid.split(' ');\r\n\r\n    const anchorStartCentroid = new Point(parseFloat(anchorStartStringParts[0]), parseFloat(anchorStartStringParts[1]));\r\n    const anchorEndCentroid = new Point(parseFloat(anchorEndStringParts[0]), parseFloat(anchorEndStringParts[1]));\r\n    const anchorPointMinDist = _routingPointsAroundAnchorSet.findDistanceToPointClosestTo(anchorStartCentroid);\r\n\r\n    // Find adjustedStart, adjustedEnd .. anchor points closest to the desired start point and end point\r\n    // Note that when desired start or end are closed off within a boundary, values will be null\r\n    const adjustedStart = _routingPointsAroundAnchorSet\r\n        .findPointsCloseTo(anchorStartCentroid, anchorPointMinDist) // get all points within radius\r\n        .findPointClosestTo(anchorEndCentroid); // for all points within radius, get the once closest to the endpoint\r\n\r\n    const adjustedEnd = _routingPointsAroundAnchorSet\r\n        .findPointsCloseTo(anchorEndCentroid, anchorPointMinDist)\r\n        .findPointClosestTo(anchorStartCentroid);\r\n\r\n    const routingPoints = _pointVisibilityMap.computeRoute(adjustedStart, adjustedEnd);\r\n    const routingPointsArray = routingPoints.toArray();\r\n\r\n    // Put together all points for path\r\n    const allPointsForPath = [anchorStartCentroid, ...routingPointsArray, anchorEndCentroid];\r\n\r\n    return {\r\n        \"svgPath\": SvgPathBuilder.pointsToPath(allPointsForPath),\r\n        \"pointsInPath\": allPointsForPath,\r\n    }\r\n};\r\n\r\nconst convertArrayBufferToFloat64Array = function(_ab) {\r\n    return new Float64Array(_ab);\r\n};\r\n\r\nonmessage = function(_msg) {\r\n\r\n    const metrics = {};\r\n    metrics.overallTime = null;\r\n    const overallTimeT1 = new Date();\r\n\r\n    const gridSize = _msg.data.gridSize;\r\n\r\n    const connectorDescriptors = _msg.data.connectorDescriptors;\r\n\r\n    const routingPointsSet = new PointSet(convertArrayBufferToFloat64Array(_msg.data.routingPoints));\r\n    const boundaryLinesSet = new LineSet(convertArrayBufferToFloat64Array(_msg.data.boundaryLines));    \r\n    const routingPointsAroundAnchorSet = new PointSet(convertArrayBufferToFloat64Array(_msg.data.routingPointsAroundAnchor));    \r\n    \r\n    const currentPointVisiblityMap = new PointVisibilityMap(\r\n        routingPointsSet,\r\n        boundaryLinesSet\r\n    );\r\n\r\n    connectorDescriptors.forEach(function(_cd) {\r\n        const pathData = computeConnectorPath(_cd, routingPointsAroundAnchorSet, currentPointVisiblityMap);\r\n\r\n        const pointsInPathPointSet = new PointSet(pathData.pointsInPath);\r\n\r\n        _cd.svgPath = pathData.svgPath;\r\n        _cd.pointsInPath = pointsInPathPointSet.toFloat64Array().buffer;\r\n    });\r\n\r\n    metrics.overallTime = (new Date()) - overallTimeT1;\r\n    metrics.numRoutingPoints = routingPointsSet.count();\r\n    metrics.numBoundaryLines = boundaryLinesSet.count();\r\n\r\n    postMessage(\r\n        {\r\n            \"connectorDescriptors\": connectorDescriptors,\r\n            \"metrics\": metrics\r\n        }\r\n    );\r\n\r\n};\r\n"],"names":["Point","_x","_y","__x","__y","prototype","getX","getY","isEqual","_otherPoint","getCartesianPoint","_canvasWidth","_canvasHeight","toString","LINE_INTERSECTION_TYPE","Object","freeze","PARALLEL","COINCIDENT","LINE","LINESEG","LineIntersection","_type","_intersectionPoint","getType","getIntersectionPoint","Line","_startPoint","_endPoint","__startPoint","__endPoint","getStartPoint","getEndPoint","_otherLine","getLength","Math","sqrt","pow","computeIntersectionType","thisLineStartPointX","thisLineStartPointY","thisLineEndPointX","thisLineEndPointY","otherLineStartPointX","otherLineStartPointY","otherLineEndPointX","otherLineEndPointY","paramDenom","paramANumer","paramBNumer","paramA","paramB","computeIntersection","xIntersect","yIntersect","PointSet","_pointsInput","self","points","push","_newPoint","i","length","pushPointSet","_ps","possibleNewPoints","toArray","findPointClosestTo","_point","resultPoint","currentMinLength","Number","MAX_SAFE_INTEGER","forEach","_pt","lineToPt","findDistanceToPointClosestTo","findPointsCloseTo","_radius","resultSet","toFloat64Array","result","Float64Array","fromFloat64Array","_float64Array","count","Array","isArray","call","LineSet","_linesInput","lines","_newLine","alreadyInLinesArray","_existingLine","PointVisibilityMap","_freePoints","_boundaryLines","boundaryLinesArr","freePointsArr","pointToVisibleSet","doesLineIntersectAnyBoundaryLines","_theLine","intersectionType","b","computePointsVisibility","ijLine","j","getVisiblePointsFrom","_currentPoint","visiblePoints","routeToEndpoint","_currentRouteLength","_pointsInRoute","curMinCost","visiblePointWithMinCost","_vp","gn","hn","optimizeRoute","ptrA","ln","splice","currentMaxLength","_ptKey","lineOfSight","findVisiblePointClosestTo","_freePt","lineOfSightLength","computeRoute","firstRoutingPoint","routeSegment","currentRouteLen","pointsInRoute","currentPoint","lastSegmentToEndpoint","point","SvgPathBuilder","pointToLineTo","pointsToPath","_points","p","startPt","lineToString","startCoordString","pathString","join","computeConnectorPath","_connectorDescriptor","_routingPointsAroundAnchorSet","_pointVisibilityMap","anchorStartStringParts","anchor_start_centroid","split","anchorEndStringParts","anchor_end_centroid","anchorStartCentroid","parseFloat","anchorEndCentroid","anchorPointMinDist","adjustedStart","adjustedEnd","routingPoints","routingPointsArray","allPointsForPath","convertArrayBufferToFloat64Array","_ab","onmessage","_msg","metrics","overallTime","overallTimeT1","Date","gridSize","data","connectorDescriptors","routingPointsSet","boundaryLinesSet","boundaryLines","routingPointsAroundAnchorSet","routingPointsAroundAnchor","currentPointVisiblityMap","_cd","pathData","pointsInPathPointSet","pointsInPath","svgPath","buffer","numRoutingPoints","numBoundaryLines","postMessage"],"mappings":"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"}